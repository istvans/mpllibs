#!/usr/bin/perl
# Copyright Istvan Siroki (stevesiroki@gmail.com) 2013.
# Distributed under the Boost Software License, Version 1.0.
#    (See accompanying file LICENSE_1_0.txt or copy at
#          http://www.boost.org/LICENSE_1_0.txt)
use strict;
use warnings;

use Data::Dumper;

my $NUMBER_OF_TEST_CASES = 5;

#-----------------------------------------------------------------------------#
# Processing the test cases read from the file
sub get_tests
{
  my ($tc) = @_;

  my @test_cases = ();
  my $ntc = 0;
  my $test_case = undef;
  foreach my $t (@$tc) {
    next if ($t =~ /^\s*;/ || $t =~ /^\s*$/);
    chomp ($t);

    if ($t =~ /^\[[^e][^n][^d].+\]$/) {
      $test_case = undef; # reset

      $test_case->{name} = $t;
    }
    elsif ($t =~ /^str=>?(.*)$/) {
      $test_case->{str} = $1;
    }
    elsif ($t =~ /^pat=(.*)$/) {
      $test_case->{pat} = $1;
    }
    elsif ($t =~ /^flg=(.*)$/) {
      $test_case->{flg} = $1;
    }
    elsif ($t =~ /^sub=(.*)$/) {
      $test_case->{sub} = $1;
    }
    elsif ($t =~ /^br\d+=(.*)$/) {
      push (@{$test_case->{br}}, $1);
    }
    elsif ($t =~ /^\[end\]$/) {
      next if ( (defined $test_case->{sub} && $test_case->{sub} !~ /^\s*$/)
             || (defined $test_case->{flg} && $test_case->{flg} !~ /^\s*$/) );

#      last if ($ntc >= $NUMBER_OF_TEST_CASES);

      ++$ntc;
      $test_case->{match} = (!defined $test_case->{br} || scalar(@{$test_case->{br}}) == 0) ? 0 : 1;
      push (@test_cases, $test_case);
    }
  }
  $test_cases[0]->{number_of_tests} = $ntc;

  return \@test_cases;
}

#-----------------------------------------------------------------------------#

my $filename = (defined $ARGV[0]) ? $ARGV[0] : "regress.txt";
open (my $TEST_FILE, "<$filename") or die "Cannot open $filename ($!)";
my @raw_test_cases = <$TEST_FILE>;
close ($TEST_FILE);

my $test_cases = get_tests(\@raw_test_cases);
#print Dumper($test_cases);

print "// Copyright Istvan Siroki (stevesiroki\@gmail.com) 2013.\n";
print "// Distributed under the Boost Software License, Version 1.0.\n";
print "//    (See accompanying file LICENSE_1_0.txt or copy at\n";
print "//          http://www.boost.org/LICENSE_1_0.txt)\n";
print "\n";
print "//  THIS FILE IS GENERATED BY $0 @ARGV\n";
print "//  USED TEST CASE FILE: $filename\n";
print "//  DO NOT EDIT MANUALLY!!!\n";
print "\n";
print "#define BOOST_TEST_DYN_LINK\n";
print "\n";
print "#include <mpllibs/xlxpressive/regexp_grammar.hpp>\n";
print "\n";
print "#include <boost/test/unit_test.hpp>\n";
print "\n";
print "#include <boost/mpl/string.hpp>\n";
print "\n";
print "#include <string>\n";
print "\n";
print "#include \"search.hpp\"\n";
print "\n";
print "BOOST_AUTO_TEST_CASE(test_grammar)\n";
print "{\n";
print "  std::vector<std::string> matched;\n";
printf "  //Number of test cases: %i\n", $test_cases->[0]->{number_of_tests};

my $CHAR_LIMIT = 4;
for (my $k = 0; $k < scalar(@$test_cases); ++$k) {
  my $test_case = \%{$test_cases->[$k]};
  print "\n  //",$test_case->{name},"\n";
  
  my $perl_match = 0;
  my $preprocessed_pattern = $test_case->{pat};
  $preprocessed_pattern =~ s#\\\\(?=[bBwWdDsSnr\$^.])#\\#g;
  $preprocessed_pattern =~ s#(?<=[^\\])\\\\\\(?=[^\\])#\\\\\\\\#g;
  $preprocessed_pattern =~ s#\\\\(\d)#\\$1#g;
  
  my $preprocessed_string = $test_case->{str};
  $preprocessed_string =~ s#\\\\#\\#g;

#  print "'$preprocessed_pattern' '$preprocessed_string' '$test_case->{match}'\n";
  if (!$test_case->{match}) {
    $perl_match = 1 if ("$preprocessed_string" !~ /$preprocessed_pattern/);
  }
  else {
    $perl_match = 1 if ("$preprocessed_string" =~ /$preprocessed_pattern/);
  }
  print  "  BOOST_REQUIRE(" . (($perl_match) ? "true" : "false") . "); //perl test\n";

  my @re_chars = split(//, $test_case->{pat});
  my $regexp = "'";
  for (my $k = 0; $k < scalar(@re_chars); ++$k) {
    $regexp .= $re_chars[$k];
    if (($k+1) % $CHAR_LIMIT == 0 || ($k+2 < scalar(@re_chars) && $re_chars[$k+1] =~ /\\/ && $re_chars[$k+2] =~ /\\/) && ($k+3>=scalar(@re_chars) || $re_chars[$k+3] !~ /\\/) ) {
      if ($k == (scalar(@re_chars)-1)) {
        $regexp .= "'";
      }
      else {
        $regexp .= "','";
      }
    }
  }
  $regexp .= "'" if (substr($regexp, length($regexp)-1, 1) ne "'");
  $regexp =~ s#,'\\','([^']{1,3})'#,'\\$1'#g;
  $regexp =~ s#\\','([^']{3})([^'])'#','\\$1','$2'#g;

  $regexp =~ s#,'',#,#g;

  foreach my $br (@{$test_case->{br}}) {
    printf "  matched.push_back(\"%s\");\n", $br;
  }

  printf "  typedef boost::mpl::string< %s > Regexp%i;\n", $regexp, $k;
  printf "  BOOST_REQUIRE( search< Regexp%i >(\"%s\", matched) );\n", $k, $test_case->{str};
  print  "  matched.clear();\n";
}

print "}\n\n";

